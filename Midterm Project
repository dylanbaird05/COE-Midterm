#include <iostream>
#include <vector>
#include <algorithm> 
#include <random>    
#include <ctime>     

using std::cout;
using std::endl;
using std::string;
using std::vector;

class Card {
private:
    string suit;
    string label;
    int value;
    int alternateValue;
    int sortValue;

public:
    Card(string suit, string label, int value, int alternateValue, int sortValue) :
            suit(suit), label(label), value(value), alternateValue(alternateValue), sortValue(sortValue) {}

    void displayCard() const {
        cout << "Suit: " << suit << endl;
        cout << "Label: " << label << endl;
        cout << "Value: " << value << endl;
        cout << "Alternate Value: " << alternateValue << endl;
        cout << "Sort Value: " << sortValue << endl;
    }
};

class Deck {
private:
    vector<Card> cards;

public:
    void addCard(Card new_card) {
        cards.push_back(new_card);
    }

    Card dealCard() {
        Card dealt_card = cards.back();
        cards.pop_back();
        return dealt_card;
    }

    Deck splitDeck() {
        Deck split;
        int half_size = cards.size() / 2;
        for (int i = 0; i < half_size; ++i) {
            split.addCard(cards.back());
            cards.pop_back();
        }
        return split;
    }

    void shuffleDeck(int number) {
        std::default_random_engine rng(std::time(nullptr));
        for (int i = 0; i < number; i++) {
            std::shuffle(cards.begin(), cards.end(), rng);
        }
    }

    int cardCount() {
        return cards.size();
    }

    void displayDeck() const {
        for (const auto &card : cards) {
            card.displayCard();
            cout << "------------------" << endl;
        }
    }

    void RiffleShuffle(Deck& subdeck1, Deck& subdeck2)
    {
    Deck shuffledDeck;
    int totalCards = subdeck1.cardCount() + subdeck2.cardCount();

    // Perform riffle shuffle
    while (subdeck1.cardCount() > 0 && subdeck2.cardCount() > 0) {
        shuffledDeck.addCard(subdeck1.dealCard());
        shuffledDeck.addCard(subdeck2.dealCard());
    }

    // If one subdeck still has cards remaining, add them to the shuffled deck
    while (subdeck1.cardCount() > 0) {
        shuffledDeck.addCard(subdeck1.dealCard());
    }

    while (subdeck2.cardCount() > 0) {
        shuffledDeck.addCard(subdeck2.dealCard());
    }

    // Replace the original deck with the shuffled one
    subdeck1 = shuffledDeck;
    }
};

// Function to assign values to card properties based on label
void assignCardValues(const string &label, int &value, int &alternateValue, int &sortValue) {
    if (label == "Ace") {
        value = 1;
        alternateValue = 11; // Assuming alternate value of 11 for Ace
    } else if (label == "Jack" || label == "Queen" || label == "King") {
        value = 10;
        alternateValue = 10;
    } else {
        value = std::stoi(label);
        alternateValue = value;
    }

    // Assign sort value based on label
    if (label == "Ace") {
        sortValue = 1; // Sort Ace first
    } else if (label == "Jack") {
        sortValue = 11;
    } else if (label == "Queen") {
        sortValue = 12;
    } else if (label == "King") {
        sortValue = 13;
    } else {
        sortValue = value;
    }
}

int main() {
    Deck myDeck;

    vector<string> suits = {"Hearts", "Diamonds", "Clubs", "Spades"};
    vector<string> labels = {"Ace", "2", "3", "4", "5", "6", "7", "8", "9", "10", "Jack", "Queen", "King"};

    for (const auto& suit : suits) {
        for (const auto& label : labels) {
            int value, alternateValue, sortValue;
            assignCardValues(label, value, alternateValue, sortValue);
            myDeck.addCard(Card(suit, label, value, alternateValue, sortValue));
        }
    }

    cout << "Original Deck:" << endl;
    myDeck.displayDeck();

    Deck subdeck1 = myDeck.splitDeck();
    Deck subdeck2 = myDeck;

    //cout << "Subdeck 1:" << endl;
    //subdeck1.displayDeck();

    //cout << "Subdeck 2:" << endl;
    //subdeck2.displayDeck();

    // Perform riffle shuffle
    //RiffleShuffle(subdeck1, subdeck2);

    // Display the shuffled deck
    //cout << "Riffle Shuffled Deck:" << endl;
    //subdeck1.displayDeck();

    return 0;
}
